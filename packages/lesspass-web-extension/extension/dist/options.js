/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extension/src/options.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************!*\
  !*** D:/sources/lesspass/node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./extension/src/components/OptionsPage.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  computed: Object(vuex__WEBPACK_IMPORTED_MODULE_0__["mapState"])(["defaultPassword"]),
  methods: {
    saveOptions: function saveOptions(login) {
      this.$store.commit("updateDefaultLogin", login);
    }
  }
});

/***/ }),

/***/ "../../node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** D:/sources/lesspass/node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!D:/sources/lesspass/node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib??vue-loader-options!./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".full-width {\n  width: 100%;\n}\n", ""]);


/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/api.js":
/*!***********************************************************************!*\
  !*** D:/sources/lesspass/node_modules/css-loader/dist/runtime/api.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names

module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "../../node_modules/style-loader/index.js!../../node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** D:/sources/lesspass/node_modules/style-loader!D:/sources/lesspass/node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!D:/sources/lesspass/node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib??vue-loader-options!./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib??vue-loader-options!./OptionsPage.vue?vue&type=style&index=0&lang=css& */ "../../node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css&");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/lib/addStyles.js */ "../../node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "../../node_modules/style-loader/lib/addStyles.js":
/*!**********************************************************************!*\
  !*** D:/sources/lesspass/node_modules/style-loader/lib/addStyles.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "../../node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "../../node_modules/style-loader/lib/urls.js":
/*!*****************************************************************!*\
  !*** D:/sources/lesspass/node_modules/style-loader/lib/urls.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "../lesspass-pure/src/store/defaultPassword.js":
/*!*****************************************************!*\
  !*** ../lesspass-pure/src/store/defaultPassword.js ***!
  \*****************************************************/
/*! exports provided: defaultOptions, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
const defaultOptions = {
  uppercase: true,
  lowercase: true,
  numbers: true,
  symbols: true,
  length: 16,
  counter: 1,
  version: 2
};
/* harmony default export */ __webpack_exports__["default"] = ({
  login: "",
  site: "",
  ...defaultOptions
});

/***/ }),

/***/ "./extension/src/components/OptionsPage.vue":
/*!**************************************************!*\
  !*** ./extension/src/components/OptionsPage.vue ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OptionsPage_vue_vue_type_template_id_6df79bc6___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OptionsPage.vue?vue&type=template&id=6df79bc6& */ "./extension/src/components/OptionsPage.vue?vue&type=template&id=6df79bc6&");
/* harmony import */ var _OptionsPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OptionsPage.vue?vue&type=script&lang=js& */ "./extension/src/components/OptionsPage.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OptionsPage.vue?vue&type=style&index=0&lang=css& */ "./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _OptionsPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _OptionsPage_vue_vue_type_template_id_6df79bc6___WEBPACK_IMPORTED_MODULE_0__["render"],
  _OptionsPage_vue_vue_type_template_id_6df79bc6___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "extension/src/components/OptionsPage.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./extension/src/components/OptionsPage.vue?vue&type=script&lang=js&":
/*!***************************************************************************!*\
  !*** ./extension/src/components/OptionsPage.vue?vue&type=script&lang=js& ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/babel-loader/lib!../../../node_modules/vue-loader/lib??vue-loader-options!./OptionsPage.vue?vue&type=script&lang=js& */ "../../node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css&":
/*!***********************************************************************************!*\
  !*** ./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css& ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/style-loader!../../../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib??vue-loader-options!./OptionsPage.vue?vue&type=style&index=0&lang=css& */ "../../node_modules/style-loader/index.js!../../node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=style&index=0&lang=css&");
/* harmony import */ var _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_style_loader_index_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "./extension/src/components/OptionsPage.vue?vue&type=template&id=6df79bc6&":
/*!*********************************************************************************!*\
  !*** ./extension/src/components/OptionsPage.vue?vue&type=template&id=6df79bc6& ***!
  \*********************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_template_id_6df79bc6___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./OptionsPage.vue?vue&type=template&id=6df79bc6& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=template&id=6df79bc6&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_template_id_6df79bc6___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_OptionsPage_vue_vue_type_template_id_6df79bc6___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./extension/src/options.js":
/*!**********************************!*\
  !*** ./extension/src/options.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _components_OptionsPage_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/OptionsPage.vue */ "./extension/src/components/OptionsPage.vue");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store */ "./extension/src/store/index.js");



new vue__WEBPACK_IMPORTED_MODULE_0__["default"]({
  el: "#lesspass-options",
  render: function render(h) {
    return h(_components_OptionsPage_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
  },
  store: _store__WEBPACK_IMPORTED_MODULE_2__["default"]
});

/***/ }),

/***/ "./extension/src/store/index.js":
/*!**************************************!*\
  !*** ./extension/src/store/index.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm.js");
/* harmony import */ var vuex_persistedstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vuex-persistedstate */ "./node_modules/vuex-persistedstate/dist/vuex-persistedstate.es.js");
/* harmony import */ var _lesspass_pure_src_store_defaultPassword__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../lesspass-pure/src/store/defaultPassword */ "../lesspass-pure/src/store/defaultPassword.js");




vue__WEBPACK_IMPORTED_MODULE_0__["default"].use(vuex__WEBPACK_IMPORTED_MODULE_1__["default"]);
var state = {
  message: "",
  defaultPassword: _lesspass_pure_src_store_defaultPassword__WEBPACK_IMPORTED_MODULE_3__["default"]
};
/* harmony default export */ __webpack_exports__["default"] = (new vuex__WEBPACK_IMPORTED_MODULE_1__["default"].Store({
  state: state,
  plugins: [Object(vuex_persistedstate__WEBPACK_IMPORTED_MODULE_2__["default"])({
    key: "lesspass",
    paths: ["defaultPassword"]
  })],
  mutations: {
    updateDefaultLogin: function updateDefaultLogin(state, login) {
      state.defaultPassword.login = login;
    }
  }
}));

/***/ }),

/***/ "./node_modules/deepmerge/dist/es.js":
/*!*******************************************!*\
  !*** ./node_modules/deepmerge/dist/es.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};

function isNonNullObject(value) {
  return !!value && typeof value === 'object';
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
} // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}

function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}

function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function (element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}

function mergeObject(target, source, options) {
  var destination = {};

  if (options.isMergeableObject(target)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }

  Object.keys(source).forEach(function (key) {
    if (!options.isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    } else {
      destination[key] = deepmerge(target[key], source[key], options);
    }
  });
  return destination;
}

function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}

deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }

  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};

var deepmerge_1 = deepmerge;
/* harmony default export */ __webpack_exports__["default"] = (deepmerge_1);

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 68
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/shvl/dist/shvl.es.js":
/*!*******************************************!*\
  !*** ./node_modules/shvl/dist/shvl.es.js ***!
  \*******************************************/
/*! exports provided: get, set */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return n; });
function t(t, n, r) {
  return void 0 === (t = (n.split ? n.split(".") : n).reduce(function (t, n) {
    return t && t[n];
  }, t)) ? r : t;
}

function n(t, n, r, e) {
  return (n = n.split ? n.split(".") : n).slice(0, -1).reduce(function (t, n) {
    return t[n] = t[n] || {};
  }, t)[n.pop()] = r, t;
}



/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./extension/src/components/OptionsPage.vue?vue&type=template&id=6df79bc6&":
/*!***************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./extension/src/components/OptionsPage.vue?vue&type=template&id=6df79bc6& ***!
  \***************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "form",
    {
      attrs: { id: "lesspass-options-form", novalidate: "" },
      on: {
        submit: function($event) {
          return _vm.saveOptions(_vm.defaultPassword.login)
        }
      }
    },
    [
      _c("div", { staticClass: "form-group row full-width" }, [
        _c(
          "label",
          { staticClass: "col-sm-2 col-form-label", attrs: { for: "login" } },
          [_vm._v("Default login")]
        ),
        _vm._v(" "),
        _c("div", { staticClass: "col-sm-10" }, [
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.defaultPassword.login,
                expression: "defaultPassword.login"
              }
            ],
            ref: "login",
            staticClass: "form-control",
            attrs: {
              id: "login",
              type: "text",
              name: "login",
              autocomplete: "off",
              autocorrect: "off",
              autocapitalize: "none"
            },
            domProps: { value: _vm.defaultPassword.login },
            on: {
              input: function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.$set(_vm.defaultPassword, "login", $event.target.value)
              }
            }
          })
        ])
      ]),
      _vm._v(" "),
      _vm._m(0)
    ]
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "form-group row" }, [
      _c("div", { staticClass: "col-sm-10" }, [
        _c(
          "button",
          { staticClass: "btn btn-primary", attrs: { type: "submit" } },
          [_vm._v("Save")]
        )
      ])
    ])
  }
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity = function (_) {
  return _;
};
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ( true && customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ( true && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if (true) {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if (true) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ( true && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if (true) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ( true && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();

  try {
    if (vm) {
      var cur = vm;

      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;

        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;

              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }

    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      }); // issue #9511
      // avoid catch triggering multiple times when nested calls

      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */

/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
       true && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if (true) {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
    ) ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
       true && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);

        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
res, // the following are added in 2.6
hasDynamicKeys, contentHashKey) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  if (contentHashKey) {
    res.$key = contentHashKey;
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
     true && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  var owner = currentRenderingInstance;

  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on('hook:destroyed', function () {
      return remove(owners, owner);
    });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;

        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }

        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
       true && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;

              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;

            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : undefined);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if (true) {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.


  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if (true) {
    circular = {};
  }

  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)

if (inBrowser && !isIE) {
  var performance = window.performance;

  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () {
      return performance.now();
    };
  }
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : undefined; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop;
       true && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if (true) {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {} // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
     true && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
       true && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ( true && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }

  if ( true && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if (true) {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if (true) {
      initProxy(vm);
    } else {} // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if ( true && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.10';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
       true && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

/*  */

/*  */

/*  */
// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.

function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
      // #9681 QtWebEngine event.timeStamp is negative value
      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if ( // skip the update if old and new VDOM state is the same.
    // `value` is handled separately because the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This  #4521 by skipping the unnecesarry `checked` update.
    cur !== oldProps[key]) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
     true && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ( true && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (true) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if ( true && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


/* harmony default export */ __webpack_exports__["default"] = (Vue);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/vuex-persistedstate/dist/vuex-persistedstate.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vuex-persistedstate/dist/vuex-persistedstate.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/es.js");
/* harmony import */ var shvl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shvl */ "./node_modules/shvl/dist/shvl.es.js");


/* harmony default export */ __webpack_exports__["default"] = (function (n, o, u) {
  function i(t, e, r) {
    try {
      return (r = e.getItem(t)) && void 0 !== r ? JSON.parse(r) : void 0;
    } catch (t) {}
  }

  if (o = (n = n || {}).storage || window && window.localStorage, u = n.key || "vuex", !function (t) {
    try {
      return t.setItem("@@", 1), t.removeItem("@@"), !0;
    } catch (t) {}

    return !1;
  }(o)) throw new Error("Invalid storage instance given");
  return function (c) {
    var a = Object(shvl__WEBPACK_IMPORTED_MODULE_1__["get"])(n, "getState", i)(u, o);
    "object" == typeof a && null !== a && c.replaceState(Object(deepmerge__WEBPACK_IMPORTED_MODULE_0__["default"])(c.state, a, {
      arrayMerge: n.arrayMerger || function (t, e) {
        return e;
      },
      clone: !1
    })), (n.subscriber || function (t) {
      return function (e) {
        return t.subscribe(e);
      };
    })(c)(function (t, i) {
      (n.filter || function () {
        return !0;
      })(t) && (n.setState || function (t, e, r) {
        return r.setItem(t, JSON.stringify(e));
      })(u, (n.reducer || function (t, n) {
        return 0 === n.length ? t : n.reduce(function (n, o) {
          return Object(shvl__WEBPACK_IMPORTED_MODULE_1__["set"])(n, o, Object(shvl__WEBPACK_IMPORTED_MODULE_1__["get"])(t, o));
        }, {});
      })(i, n.paths || []), o);
    });
  };
});
;

/***/ }),

/***/ "./node_modules/vuex/dist/vuex.esm.js":
/*!********************************************!*\
  !*** ./node_modules/vuex/dist/vuex.esm.js ***!
  \********************************************/
/*! exports provided: default, Store, install, mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return Store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "install", function() { return install; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapState", function() { return mapState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapMutations", function() { return mapMutations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapGetters", function() { return mapGetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapActions", function() { return mapActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNamespacedHelpers", function() { return createNamespacedHelpers; });
/**
 * vuex v3.1.1
 * (c) 2019 Evan You
 * @license MIT
 */
function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({
      beforeCreate: vuexInit
    });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;

    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};
      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;

      _init.call(this, options);
    };
  }
  /**
   * Vuex init hook, injected into each instances init hooks list.
   */


  function vuexInit() {
    var options = this.$options; // store injection

    if (options.store) {
      this.$store = typeof options.store === 'function' ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;
  devtoolHook.emit('vuex:init', store);
  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });
  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}
/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */

/**
 * forEach for object
 */


function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

function partial(fn, arg) {
  return function () {
    return fn(arg);
  };
} // Base data struct for store's module, package with some attribute and method


var Module = function Module(rawModule, runtime) {
  this.runtime = runtime; // Store some children item

  this._children = Object.create(null); // Store the origin module object which passed by programmer

  this._rawModule = rawModule;
  var rawState = rawModule.state; // Store the origin module's state

  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = {
  namespaced: {
    configurable: true
  }
};

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;

  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }

  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }

  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  if (true) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);

  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  } // register nested modules


  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(path, targetModule, newModule) {
  if (true) {
    assertRawModule(path, newModule);
  } // update target module


  targetModule.update(newModule); // update nested modules

  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (true) {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        }

        return;
      }

      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var functionAssert = {
  assert: function (value) {
    return typeof value === 'function';
  },
  expected: 'function'
};
var objectAssert = {
  assert: function (value) {
    return typeof value === 'function' || typeof value === 'object' && typeof value.handler === 'function';
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function (value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}

function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";

  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }

  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {}; // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731

  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (true) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins;
  if (plugins === void 0) plugins = [];
  var strict = options.strict;
  if (strict === void 0) strict = false; // store internal state

  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue(); // bind commit and dispatch to self

  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;

  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };

  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  }; // strict mode


  this.strict = strict;
  var state = this._modules.root.state; // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters

  installModule(this, state, [], this._modules.root); // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)

  resetStoreVM(this, state); // apply plugins

  plugins.forEach(function (plugin) {
    return plugin(this$1);
  });
  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;

  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = {
  state: {
    configurable: true
  }
};

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors$1.state.set = function (v) {
  if (true) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this; // check object-style commit

  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;
  var mutation = {
    type: type,
    payload: payload
  };
  var entry = this._mutations[type];

  if (!entry) {
    if (true) {
      console.error("[vuex] unknown mutation type: " + type);
    }

    return;
  }

  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });

  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if ( true && options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1 = this; // check object-style dispatch

  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;
  var action = {
    type: type,
    payload: payload
  };
  var entry = this._actions[type];

  if (!entry) {
    if (true) {
      console.error("[vuex] unknown action type: " + type);
    }

    return;
  }

  try {
    this._actionSubscribers.filter(function (sub) {
      return sub.before;
    }).forEach(function (sub) {
      return sub.before(action, this$1.state);
    });
  } catch (e) {
    if (true) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
  return result.then(function (res) {
    try {
      this$1._actionSubscribers.filter(function (sub) {
        return sub.after;
      }).forEach(function (sub) {
        return sub.after(action, this$1.state);
      });
    } catch (e) {
      if (true) {
        console.warn("[vuex] error in after action subscribers: ");
        console.error(e);
      }
    }

    return res;
  });
};

Store.prototype.subscribe = function subscribe(fn) {
  return genericSubscribe(fn, this._subscribers);
};

Store.prototype.subscribeAction = function subscribeAction(fn) {
  var subs = typeof fn === 'function' ? {
    before: fn
  } : fn;
  return genericSubscribe(subs, this._actionSubscribers);
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  if (true) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }

  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0) options = {};

  if (typeof path === 'string') {
    path = [path];
  }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);

  installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);

  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });

  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);

  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors$1);

function genericSubscribe(fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }

  return function () {
    var i = subs.indexOf(fn);

    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state; // init all modules

  installModule(store, state, [], store._modules.root, true); // reset vm

  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm; // bind store public getters

  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure enviroment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () {
        return store._vm[key];
      },
      enumerable: true // for local getters

    });
  }); // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins

  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent; // enable strict mode for new vm

  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }

    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;

  var namespace = store._modules.getNamespace(path); // register in namespace map


  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  } // set state


  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];

    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);
  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */


function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';
  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if ( true && !store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if ( true && !store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  }; // getters and state object must be gotten lazily
  // because they will be changed by vm update

  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function () {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};
  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    } // extract local getter type


    var localType = type.slice(splitPos); // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.

    Object.defineProperty(gettersProxy, localType, {
      get: function () {
        return store.getters[type];
      },
      enumerable: true
    });
  });
  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);

    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }

    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);

        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (true) {
      console.error("[vuex] duplicate getter key: " + type);
    }

    return;
  }

  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    if (true) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, {
    deep: true,
    sync: true
  });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (true) {
    assert(typeof type === 'string', "expects string as the type, but found " + typeof type + ".");
  }

  return {
    type: type,
    payload: payload,
    options: options
  };
}

function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if (true) {
      console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    }

    return;
  }

  Vue = _Vue;
  applyMixin(Vue);
}
/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */


var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

        if (!module) {
          return;
        }

        state = module.context.state;
        getters = module.context.getters;
      }

      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // Get the commit method from store


      var commit = this.$store.commit;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

        if (!module) {
          return;
        }

        commit = module.context.commit;
      }

      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val; // The namespace has been mutated by normalizeNamespace

    val = namespace + val;

    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }

      if ( true && !(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }

      return this.$store.getters[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // get dispatch function from store


      var dispatch = this.$store.dispatch;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

        if (!module) {
          return;
        }

        dispatch = module.context.dispatch;
      }

      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */

var createNamespacedHelpers = function (namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};
/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */


function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return {
      key: key,
      val: key
    };
  }) : Object.keys(map).map(function (key) {
    return {
      key: key,
      val: map[key]
    };
  });
}
/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */


function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }

    return fn(namespace, map);
  };
}
/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */


function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];

  if ( true && !module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }

  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.1.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};
/* harmony default export */ __webpack_exports__["default"] = (index_esm);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL2V4dGVuc2lvbi9zcmMvY29tcG9uZW50cy9PcHRpb25zUGFnZS52dWUiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL3NyYy9jb21wb25lbnRzL09wdGlvbnNQYWdlLnZ1ZT9iYzUxIiwid2VicGFjazovLy9EOi9zb3VyY2VzL2xlc3NwYXNzL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL3NyYy9jb21wb25lbnRzL09wdGlvbnNQYWdlLnZ1ZT80NjYwIiwid2VicGFjazovLy9EOi9zb3VyY2VzL2xlc3NwYXNzL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vRDovc291cmNlcy9sZXNzcGFzcy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uLi9sZXNzcGFzcy1wdXJlL3NyYy9zdG9yZS9kZWZhdWx0UGFzc3dvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL3NyYy9jb21wb25lbnRzL09wdGlvbnNQYWdlLnZ1ZSIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb24vc3JjL2NvbXBvbmVudHMvT3B0aW9uc1BhZ2UudnVlPzZmZGYiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL3NyYy9jb21wb25lbnRzL09wdGlvbnNQYWdlLnZ1ZT9hODkyIiwid2VicGFjazovLy8uL2V4dGVuc2lvbi9zcmMvY29tcG9uZW50cy9PcHRpb25zUGFnZS52dWU/NDYwYiIsIndlYnBhY2s6Ly8vLi9leHRlbnNpb24vc3JjL29wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL3NyYy9zdG9yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2h2bC9kaXN0L3NodmwuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vZXh0ZW5zaW9uL3NyYy9jb21wb25lbnRzL09wdGlvbnNQYWdlLnZ1ZT84MGNmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVleC1wZXJzaXN0ZWRzdGF0ZS9kaXN0L3Z1ZXgtcGVyc2lzdGVkc3RhdGUuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZXgvZGlzdC92dWV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwidG9TdHJpbmciLCJtYXAiLCJpdGVtIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJjb25jYXQiLCJqb2luIiwiaSIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImxlbmd0aCIsImlkIiwiX2kiLCJwdXNoIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VSb290Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsImNzcyIsImxvY2F0aW9uIiwid2luZG93IiwiRXJyb3IiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiY3VycmVudERpciIsInBhdGhuYW1lIiwicmVwbGFjZSIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsInRyaW0iLCJvIiwiJDEiLCJ0ZXN0IiwibmV3VXJsIiwiaW5kZXhPZiIsImRlZmF1bHRPcHRpb25zIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlIiwibnVtYmVycyIsInN5bWJvbHMiLCJjb3VudGVyIiwidmVyc2lvbiIsImxvZ2luIiwic2l0ZSIsIlZ1ZSIsImVsIiwicmVuZGVyIiwiaCIsIk9wdGlvbnNQYWdlIiwic3RvcmUiLCJ1c2UiLCJWdWV4Iiwic3RhdGUiLCJtZXNzYWdlIiwiZGVmYXVsdFBhc3N3b3JkIiwiU3RvcmUiLCJwbHVnaW5zIiwiY3JlYXRlUGVyc2lzdGVkU3RhdGUiLCJrZXkiLCJwYXRocyIsIm11dGF0aW9ucyIsInVwZGF0ZURlZmF1bHRMb2dpbiIsImlzTWVyZ2VhYmxlT2JqZWN0IiwidmFsdWUiLCJpc05vbk51bGxPYmplY3QiLCJpc1NwZWNpYWwiLCJzdHJpbmdWYWx1ZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIiQkdHlwZW9mIiwiZW1wdHlUYXJnZXQiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsIm9wdGlvbnMiLCJjbG9uZSIsImRlZXBtZXJnZSIsImRlZmF1bHRBcnJheU1lcmdlIiwidGFyZ2V0IiwiZWxlbWVudCIsIm1lcmdlT2JqZWN0IiwiZGVzdGluYXRpb24iLCJrZXlzIiwiZm9yRWFjaCIsImFycmF5TWVyZ2UiLCJzb3VyY2VJc0FycmF5IiwidGFyZ2V0SXNBcnJheSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJhbGwiLCJkZWVwbWVyZ2VBbGwiLCJhcnJheSIsInJlZHVjZSIsInByZXYiLCJuZXh0IiwiZGVlcG1lcmdlXzEiLCJwcm9jZXNzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsImFyZ3VtZW50cyIsIkl0ZW0iLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJnbG9iYWwiLCJ1bmRlZmluZWQiLCJzZXRJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsImRvY3VtZW50IiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJjYWxsYmFjayIsIkZ1bmN0aW9uIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJNYXRoIiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiZXZlbnQiLCJzbGljZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uIiwiY2hhbm5lbCIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3J0MiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50Iiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJnZXRQcm90b3R5cGVPZiIsInNlbGYiLCJ0IiwibiIsInIiLCJzcGxpdCIsInBvcCIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwicmVxdWlyZSIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNVbmRlZiIsInYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwidG9SYXdUeXBlIiwiaXNQbGFpbk9iamVjdCIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImlzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImNyZWF0ZSIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsImluZGV4Iiwic3BsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJjYWNoZWQiLCJmbiIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwiYiIsIm5vIiwiaWRlbnRpdHkiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiRGF0ZSIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiYXN5bmMiLCJfbGlmZWN5Y2xlSG9va3MiLCJ1bmljb2RlUmVnRXhwIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsIlJlZ0V4cCIsInBhcnNlUGF0aCIsInBhdGgiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiaXNQaGFudG9tSlMiLCJpc0ZGIiwibWF0Y2giLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsImdldCIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImVycm9yIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsImNpZCIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiY29uc3RydWN0b3IiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsInVpZCIsIkRlcCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJhZGREZXAiLCJub3RpZnkiLCJzb3J0IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwiVk5vZGUiLCJ0YWciLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwiZGVsIiwic3RyYXRzIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsImhvb2tzIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsInR5cGUiLCJrZXkkMSIsInByb3BzIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJkZWYkJDEiLCJtZXJnZU9wdGlvbnMiLCJfYmFzZSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4IiwiQm9vbGVhbiIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiYXNzZXJ0UHJvcCIsImRlZmF1bHQiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiZ2V0SW52YWxpZFR5cGVNZXNzYWdlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsImlzU2FtZVR5cGUiLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJOdW1iZXIiLCJleHBsaWNpdFR5cGVzIiwic29tZSIsImVsZW0iLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwiaW52b2tlV2l0aEVycm9ySGFuZGxpbmciLCJoYW5kbGVyIiwiX2hhbmRsZWQiLCJsb2dFcnJvciIsImlzVXNpbmdNaWNyb1Rhc2siLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJ0aW1lckZ1bmMiLCJQcm9taXNlIiwicCIsInJlc29sdmUiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiY2hhcmFjdGVyRGF0YSIsImNiIiwiX3Jlc29sdmUiLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50Iiwid2FyblJlc2VydmVkUHJlZml4IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsIiRkYXRhIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsInNlZW5PYmplY3RzIiwidHJhdmVyc2UiLCJfdHJhdmVyc2UiLCJzZWVuIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsInBhcmFtcyIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJsYXN0SW5kZXgiLCJzaGlmdCIsIl9pc1ZMaXN0IiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5IiwicHJvdmlkZURlZmF1bHQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJub3JtYWxpemVTY29wZWRTbG90cyIsIm5vcm1hbFNsb3RzIiwicHJldlNsb3RzIiwiaGFzTm9ybWFsU2xvdHMiLCJpc1N0YWJsZSIsIiRzdGFibGUiLCIka2V5IiwiX25vcm1hbGl6ZWQiLCIkaGFzTm9ybWFsIiwibm9ybWFsaXplU2NvcGVkU2xvdCIsImtleSQyIiwicHJveHlOb3JtYWxTbG90IiwicHJveHkiLCJyZW5kZXJMaXN0IiwiaXRlcmF0b3IiLCJkb25lIiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIiRzY29wZWRTbG90cyIsIm5vZGVzIiwiJHNsb3RzIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImxvb3AiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsImh5cGhlbmF0ZWRLZXkiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwic3RhdGljUmVuZGVyRm5zIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJvdXJzIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaGFzRHluYW1pY0tleXMiLCJjb250ZW50SGFzaEtleSIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJ2YWx1ZXMiLCJwcmVwZW5kTW9kaWZpZXIiLCJzeW1ib2wiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJfZCIsIl9wIiwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHQiLCJ0aGlzJDEiLCJjb250ZXh0Vm0iLCJfb3JpZ2luYWwiLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJpbmplY3Rpb25zIiwic2NvcGVkU2xvdHMiLCJfc2NvcGVJZCIsIl9jIiwiZCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJkZXZ0b29sc01ldGEiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaW5pdCIsImh5ZHJhdGluZyIsIl9pc0Rlc3Ryb3llZCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiYWN0aXZlSW5zdGFuY2UiLCIkbW91bnQiLCJvbGRWbm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwiaW5zZXJ0IiwiX2lzTW91bnRlZCIsImNhbGxIb29rIiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGVzdHJveSIsIiRkZXN0cm95IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJhYnN0cmFjdCIsImluc3RhbGxDb21wb25lbnRIb29rcyIsIl9pc0NvbXBvbmVudCIsIl9wYXJlbnRWbm9kZSIsImlubGluZVRlbXBsYXRlIiwidG9NZXJnZSIsIl9tZXJnZWQiLCJtZXJnZUhvb2skMSIsImYxIiwiZjIiLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJfdm5vZGUiLCJwYXJlbnRWbm9kZSIsIl9yZW5kZXJDaGlsZHJlbiIsInBhcmVudERhdGEiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwiY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJfcmVuZGVyIiwicmVuZGVyRXJyb3IiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJmYWN0b3J5IiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJvd25lciIsIm93bmVycyIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsInN5bmMiLCJ0aW1lckxvYWRpbmciLCJ0aW1lclRpbWVvdXQiLCIkb24iLCJmb3JjZVJlbmRlciIsInJlbmRlckNvbXBsZXRlZCIsIiRmb3JjZVVwZGF0ZSIsInJlamVjdCIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsInJlbW92ZSQxIiwiJG9mZiIsIl90YXJnZXQiLCJvbmNlSGFuZGxlciIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwiJG9uY2UiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50Iiwic2V0QWN0aXZlSW5zdGFuY2UiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwicmVzdG9yZUFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwiX2RhdGEiLCJtb3VudENvbXBvbmVudCIsInRlbXBsYXRlIiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwibmV3U2NvcGVkU2xvdHMiLCJvbGRTY29wZWRTbG90cyIsImhhc0R5bmFtaWNTY29wZWRTbG90IiwibmVlZHNGb3JjZVVwZGF0ZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJkaXJlY3QiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93Iiwibm93IiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwiZGVlcCIsImxhenkiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImluaXRVc2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImZpbHRlciIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwibW91bnRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJvYnNlcnZhYmxlIiwic3NyQ29udGV4dCIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUiLCJjb252ZXJ0RW51bWVyYXRlZFZhbHVlIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJzZXRTdHlsZVNjb3BlIiwic2NvcGVJZCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwicGFyZW50RWxtIiwicmVmRWxtIiwibmVzdGVkIiwib3duZXJBcnJheSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJhcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJiYXNlU2V0QXR0ciIsInNldEF0dHJpYnV0ZU5TIiwiX19pZXBoIiwiYmxvY2tlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciQxIiwicmVtb3ZlJDIiLCJ1c2VNaWNyb3Rhc2tGaXgiLCJhZGQkMSIsImF0dGFjaGVkVGltZXN0YW1wIiwiX3dyYXBwZXIiLCJjdXJyZW50VGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsInVwZGF0ZURPTUxpc3RlbmVycyIsImV2ZW50cyIsInN2Z0NvbnRhaW5lciIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNOb3RJbkZvY3VzQW5kRGlydHkiLCJpc0RpcnR5V2l0aE1vZGlmaWVycyIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJudW1iZXIiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsIndoaXRlc3BhY2VSRSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsIl92T3B0aW9ucyIsInNldFNlbGVjdGVkIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJpc05vdFRleHROb2RlIiwiaXNWU2hvd0RpcmVjdGl2ZSIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwiYmVmb3JlTW91bnQiLCJrZXB0IiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwidSIsImdldEl0ZW0iLCJwYXJzZSIsInN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInJlcGxhY2VTdGF0ZSIsImFycmF5TWVyZ2VyIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsInNldFN0YXRlIiwicmVkdWNlciIsImFwcGx5TWl4aW4iLCJiZWZvcmVDcmVhdGUiLCJ2dWV4SW5pdCIsIiRzdG9yZSIsImRldnRvb2xIb29rIiwiZGV2dG9vbFBsdWdpbiIsIl9kZXZ0b29sSG9vayIsInRhcmdldFN0YXRlIiwibXV0YXRpb24iLCJmb3JFYWNoVmFsdWUiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJwYXJ0aWFsIiwiTW9kdWxlIiwicmF3TW9kdWxlIiwicnVudGltZSIsIl9jaGlsZHJlbiIsIl9yYXdNb2R1bGUiLCJyYXdTdGF0ZSIsIm5hbWVzcGFjZWQiLCJhZGRDaGlsZCIsImdldENoaWxkIiwiYWN0aW9ucyIsImdldHRlcnMiLCJmb3JFYWNoQ2hpbGQiLCJmb3JFYWNoR2V0dGVyIiwiZm9yRWFjaEFjdGlvbiIsImZvckVhY2hNdXRhdGlvbiIsIk1vZHVsZUNvbGxlY3Rpb24iLCJyYXdSb290TW9kdWxlIiwicmVnaXN0ZXIiLCJyb290IiwiZ2V0TmFtZXNwYWNlIiwidXBkYXRlJDEiLCJhc3NlcnRSYXdNb2R1bGUiLCJuZXdNb2R1bGUiLCJyYXdDaGlsZE1vZHVsZSIsInVucmVnaXN0ZXIiLCJ0YXJnZXRNb2R1bGUiLCJmdW5jdGlvbkFzc2VydCIsImV4cGVjdGVkIiwib2JqZWN0QXNzZXJ0IiwiYXNzZXJ0VHlwZXMiLCJhc3NlcnRPcHRpb25zIiwibWFrZUFzc2VydGlvbk1lc3NhZ2UiLCJidWYiLCJzdHJpY3QiLCJfY29tbWl0dGluZyIsIl9hY3Rpb25zIiwiX2FjdGlvblN1YnNjcmliZXJzIiwiX211dGF0aW9ucyIsIl93cmFwcGVkR2V0dGVycyIsIl9tb2R1bGVzIiwiX21vZHVsZXNOYW1lc3BhY2VNYXAiLCJfc3Vic2NyaWJlcnMiLCJfd2F0Y2hlclZNIiwiZGlzcGF0Y2giLCJjb21taXQiLCJib3VuZERpc3BhdGNoIiwicGF5bG9hZCIsImJvdW5kQ29tbWl0IiwiaW5zdGFsbE1vZHVsZSIsInJlc2V0U3RvcmVWTSIsInVzZURldnRvb2xzIiwicHJvdG90eXBlQWNjZXNzb3JzJDEiLCJfdm0iLCIkJHN0YXRlIiwiX3R5cGUiLCJfcGF5bG9hZCIsIl9vcHRpb25zIiwidW5pZnlPYmplY3RTdHlsZSIsImVudHJ5IiwiX3dpdGhDb21taXQiLCJjb21taXRJdGVyYXRvciIsImFjdGlvbiIsImFmdGVyIiwiZ2VuZXJpY1N1YnNjcmliZSIsInN1YnNjcmliZUFjdGlvbiIsInJlZ2lzdGVyTW9kdWxlIiwicHJlc2VydmVTdGF0ZSIsInVucmVnaXN0ZXJNb2R1bGUiLCJwYXJlbnRTdGF0ZSIsImdldE5lc3RlZFN0YXRlIiwicmVzZXRTdG9yZSIsImhvdFVwZGF0ZSIsIm5ld09wdGlvbnMiLCJjb21taXR0aW5nIiwiaG90Iiwib2xkVm0iLCJ3cmFwcGVkR2V0dGVycyIsImVuYWJsZVN0cmljdE1vZGUiLCJyb290U3RhdGUiLCJtb2R1bGVOYW1lIiwibG9jYWwiLCJtYWtlTG9jYWxDb250ZXh0IiwibmFtZXNwYWNlZFR5cGUiLCJyZWdpc3Rlck11dGF0aW9uIiwicmVnaXN0ZXJBY3Rpb24iLCJyZWdpc3RlckdldHRlciIsIm5vTmFtZXNwYWNlIiwibWFrZUxvY2FsR2V0dGVycyIsImdldHRlcnNQcm94eSIsInNwbGl0UG9zIiwibG9jYWxUeXBlIiwid3JhcHBlZE11dGF0aW9uSGFuZGxlciIsIndyYXBwZWRBY3Rpb25IYW5kbGVyIiwicm9vdEdldHRlcnMiLCJyYXdHZXR0ZXIiLCJ3cmFwcGVkR2V0dGVyIiwiX1Z1ZSIsIm1hcFN0YXRlIiwibm9ybWFsaXplTmFtZXNwYWNlIiwic3RhdGVzIiwibm9ybWFsaXplTWFwIiwibWFwcGVkU3RhdGUiLCJnZXRNb2R1bGVCeU5hbWVzcGFjZSIsInZ1ZXgiLCJtYXBNdXRhdGlvbnMiLCJtYXBwZWRNdXRhdGlvbiIsIm1hcEdldHRlcnMiLCJtYXBwZWRHZXR0ZXIiLCJtYXBBY3Rpb25zIiwibWFwcGVkQWN0aW9uIiwiY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnMiLCJoZWxwZXIiLCJpbmRleF9lc20iLCJnIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FB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STU0QyxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU9wRCxDQUFQLEVBQVU7QUFDWDtBQUNBLE1BQUksT0FBTzNGLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0MyaEQsQ0FBQyxHQUFHM2hELE1BQUo7QUFDaEMsQyxDQUVEO0FBQ0E7QUFDQTs7O0FBRUFwQyxNQUFNLENBQUNDLE9BQVAsR0FBaUI4akQsQ0FBakIsQyIsImZpbGUiOiJvcHRpb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9leHRlbnNpb24vc3JjL29wdGlvbnMuanNcIik7XG4iLCI8dGVtcGxhdGU+XG4gIDxmb3JtIGlkPVwibGVzc3Bhc3Mtb3B0aW9ucy1mb3JtXCIgbm92YWxpZGF0ZSBAc3VibWl0PVwic2F2ZU9wdGlvbnMoZGVmYXVsdFBhc3N3b3JkLmxvZ2luKVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCByb3cgZnVsbC13aWR0aFwiPlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJsb2dpblwiIGNsYXNzPVwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWxcIj5EZWZhdWx0IGxvZ2luPC9sYWJlbD5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTEwXCI+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgaWQ9XCJsb2dpblwiXG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgbmFtZT1cImxvZ2luXCJcbiAgICAgICAgICAgICAgcmVmPVwibG9naW5cIlxuICAgICAgICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICAgIGF1dG9jb3JyZWN0PVwib2ZmXCJcbiAgICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU9XCJub25lXCJcbiAgICAgICAgICAgICAgdi1tb2RlbD1cImRlZmF1bHRQYXNzd29yZC5sb2dpblwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS0xMFwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIj5TYXZlPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9mb3JtPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tIFwidnVleFwiO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBjb21wdXRlZDogbWFwU3RhdGUoW1wiZGVmYXVsdFBhc3N3b3JkXCJdKSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBzYXZlT3B0aW9ucyhsb2dpbikge1xuICAgICAgICB0aGlzLiRzdG9yZS5jb21taXQoXCJ1cGRhdGVEZWZhdWx0TG9naW5cIiwgbG9naW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLmZ1bGwtd2lkdGgge1xuICAgIHdpZHRoOiAxMDAlO1xuICB9XG48L3N0eWxlPlxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZnVsbC13aWR0aCB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXCIsIFwiXCJdKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vT3B0aW9uc1BhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MmXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwiZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gIHVwcGVyY2FzZTogdHJ1ZSxcclxuICBsb3dlcmNhc2U6IHRydWUsXHJcbiAgbnVtYmVyczogdHJ1ZSxcclxuICBzeW1ib2xzOiB0cnVlLFxyXG4gIGxlbmd0aDogMTYsXHJcbiAgY291bnRlcjogMSxcclxuICB2ZXJzaW9uOiAyXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbG9naW46IFwiXCIsXHJcbiAgc2l0ZTogXCJcIixcclxuICAuLi5kZWZhdWx0T3B0aW9uc1xyXG59O1xyXG4iLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL09wdGlvbnNQYWdlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02ZGY3OWJjNiZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL09wdGlvbnNQYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiRDpcXFxcc291cmNlc1xcXFxsZXNzcGFzc1xcXFxwYWNrYWdlc1xcXFxsZXNzcGFzcy13ZWItZXh0ZW5zaW9uXFxcXG5vZGVfbW9kdWxlc1xcXFx2dWUtaG90LXJlbG9hZC1hcGlcXFxcZGlzdFxcXFxpbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzZkZjc5YmM2JykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzZkZjc5YmM2JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzZkZjc5YmM2JywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmRmNzliYzYmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNmRmNzliYzYnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImV4dGVuc2lvbi9zcmMvY29tcG9uZW50cy9PcHRpb25zUGFnZS52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vT3B0aW9uc1BhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vT3B0aW9uc1BhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcyZcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9PcHRpb25zUGFnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmRmNzliYzYmXCIiLCJpbXBvcnQgVnVlIGZyb20gXCJ2dWVcIjtcbmltcG9ydCBPcHRpb25zUGFnZSBmcm9tIFwiLi9jb21wb25lbnRzL09wdGlvbnNQYWdlLnZ1ZVwiXG5pbXBvcnQgc3RvcmUgZnJvbSBcIi4vc3RvcmVcIjtcblxubmV3IFZ1ZSh7XG4gIGVsOiBcIiNsZXNzcGFzcy1vcHRpb25zXCIsXG4gIHJlbmRlcjogKGgpID0+IGgoT3B0aW9uc1BhZ2UpLFxuICBzdG9yZVxufSk7XG4iLCJpbXBvcnQgVnVlIGZyb20gXCJ2dWVcIjtcbmltcG9ydCBWdWV4IGZyb20gXCJ2dWV4XCI7XG5pbXBvcnQgY3JlYXRlUGVyc2lzdGVkU3RhdGUgZnJvbSBcInZ1ZXgtcGVyc2lzdGVkc3RhdGVcIjtcbmltcG9ydCBkZWZhdWx0UGFzc3dvcmQgZnJvbSBcIi4uLy4uLy4uLy4uL2xlc3NwYXNzLXB1cmUvc3JjL3N0b3JlL2RlZmF1bHRQYXNzd29yZFwiO1xuXG5WdWUudXNlKFZ1ZXgpO1xuXG5jb25zdCBzdGF0ZSA9IHtcbiAgbWVzc2FnZTogXCJcIixcbiAgZGVmYXVsdFBhc3N3b3JkOiBkZWZhdWx0UGFzc3dvcmQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgVnVleC5TdG9yZSh7XG4gIHN0YXRlLFxuICBwbHVnaW5zOiBbXG4gICAgY3JlYXRlUGVyc2lzdGVkU3RhdGUoe1xuICAgICAga2V5OiBcImxlc3NwYXNzXCIsXG4gICAgICBwYXRoczogW1wiZGVmYXVsdFBhc3N3b3JkXCJdXG4gICAgfSlcbiAgXSxcbiAgbXV0YXRpb25zOiB7XG4gICAgdXBkYXRlRGVmYXVsdExvZ2luKHN0YXRlLCBsb2dpbikge1xuICAgICAgc3RhdGUuZGVmYXVsdFBhc3N3b3JkLmxvZ2luID0gbG9naW47XG4gICAgfVxuICB9XG59KTtcbiIsInZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0T2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKCFvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSB8fCAhdGFyZ2V0W2tleV0pIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZXBtZXJnZV8xO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsImZ1bmN0aW9uIHQodCxuLHIpe3JldHVybiB2b2lkIDA9PT0odD0obi5zcGxpdD9uLnNwbGl0KFwiLlwiKTpuKS5yZWR1Y2UoZnVuY3Rpb24odCxuKXtyZXR1cm4gdCYmdFtuXX0sdCkpP3I6dH1mdW5jdGlvbiBuKHQsbixyLGUpe3JldHVybihuPW4uc3BsaXQ/bi5zcGxpdChcIi5cIik6bikuc2xpY2UoMCwtMSkucmVkdWNlKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbbl09dFtuXXx8e319LHQpW24ucG9wKCldPXIsdH1leHBvcnR7dCBhcyBnZXQsbiBhcyBzZXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2h2bC5lcy5qcy5tYXBcbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImZvcm1cIixcbiAgICB7XG4gICAgICBhdHRyczogeyBpZDogXCJsZXNzcGFzcy1vcHRpb25zLWZvcm1cIiwgbm92YWxpZGF0ZTogXCJcIiB9LFxuICAgICAgb246IHtcbiAgICAgICAgc3VibWl0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3ZtLnNhdmVPcHRpb25zKF92bS5kZWZhdWx0UGFzc3dvcmQubG9naW4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZm9ybS1ncm91cCByb3cgZnVsbC13aWR0aFwiIH0sIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJsYWJlbFwiLFxuICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiY29sLXNtLTIgY29sLWZvcm0tbGFiZWxcIiwgYXR0cnM6IHsgZm9yOiBcImxvZ2luXCIgfSB9LFxuICAgICAgICAgIFtfdm0uX3YoXCJEZWZhdWx0IGxvZ2luXCIpXVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbC1zbS0xMFwiIH0sIFtcbiAgICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmRlZmF1bHRQYXNzd29yZC5sb2dpbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImRlZmF1bHRQYXNzd29yZC5sb2dpblwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZWY6IFwibG9naW5cIixcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImZvcm0tY29udHJvbFwiLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgaWQ6IFwibG9naW5cIixcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIG5hbWU6IFwibG9naW5cIixcbiAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBcIm9mZlwiLFxuICAgICAgICAgICAgICBhdXRvY29ycmVjdDogXCJvZmZcIixcbiAgICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwibm9uZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5kZWZhdWx0UGFzc3dvcmQubG9naW4gfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdm0uJHNldChfdm0uZGVmYXVsdFBhc3N3b3JkLCBcImxvZ2luXCIsICRldmVudC50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9tKDApXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZvcm0tZ3JvdXAgcm93XCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2wtc20tMTBcIiB9LCBbXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJidG4gYnRuLXByaW1hcnlcIiwgYXR0cnM6IHsgdHlwZTogXCJzdWJtaXRcIiB9IH0sXG4gICAgICAgICAgW192bS5fdihcIlNhdmVcIildXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIiwiLyohXG4gKiBWdWUuanMgdjIuNi4xMFxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgPyBuYXRpdmVCaW5kXG4gIDogcG9seWZpbGxCaW5kO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBhc3luYzogdHJ1ZSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogdW5pY29kZSBsZXR0ZXJzIHVzZWQgZm9yIHBhcnNpbmcgaHRtbCB0YWdzLCBjb21wb25lbnQgbmFtZXMgYW5kIHByb3BlcnR5IHBhdGhzLlxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAqIHNraXBwaW5nIFxcdTEwMDAwLVxcdUVGRkZGIGR1ZSB0byBpdCBmcmVlemluZyB1cCBQaGFudG9tSlNcbiAqL1xudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiLiRfXFxcXGRdXCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG52YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xudmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xudmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25maWcuYXN5bmMpIHtcbiAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgIC8vIG9yZGVyXG4gICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0ICh0YXJnZXQpIHtcbiAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmIChoYXNQcm90bykge1xuICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbClcbiAgICApIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHZhciByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlcy5pbmRleE9mKGhvb2tzW2ldKSA9PT0gLTEpIHtcbiAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlIChuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKTtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICB2YXIgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiICsgZXhwZWN0ZWRWYWx1ZTtcbiAgfVxuICBtZXNzYWdlICs9IFwiLCBnb3QgXCIgKyByZWNlaXZlZFR5cGUgKyBcIiBcIjtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiICsgcmVjZWl2ZWRWYWx1ZSArIFwiLlwiO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIChcIlwiICsgKE51bWJlcih2YWx1ZSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXhwbGljYWJsZSAodmFsdWUpIHtcbiAgdmFyIGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4gKCkge1xuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nOyB9KVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZXgvaXNzdWVzLzE1MDVcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIGlmICh2bSkge1xuICAgICAgdmFyIGN1ciA9IHZtO1xuICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xuICAgICAgcmVzLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyArIFwiIChQcm9taXNlL2FzeW5jKVwiKTsgfSk7XG4gICAgICAvLyBpc3N1ZSAjOTUxMVxuICAgICAgLy8gYXZvaWQgY2F0Y2ggdHJpZ2dlcmluZyBtdWx0aXBsZSB0aW1lcyB3aGVuIG5lc3RlZCBjYWxsc1xuICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4vLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbnZhciB0aW1lckZ1bmM7XG5cbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbikpIHtcbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgdmFyIGNvdW50ZXIgPSAxO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuY2hhckF0KDApID09PSAnXycgJiYgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cyQxLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgdmFyIHNsb3RzID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzIChcbiAgc2xvdHMsXG4gIG5vcm1hbFNsb3RzLFxuICBwcmV2U2xvdHNcbikge1xuICB2YXIgcmVzO1xuICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICBpZiAoIXNsb3RzKSB7XG4gICAgcmVzID0ge307XG4gIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICByZXR1cm4gc2xvdHMuX25vcm1hbGl6ZWRcbiAgfSBlbHNlIGlmIChcbiAgICBpc1N0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgIXByZXZTbG90cy4kaGFzTm9ybWFsXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5JDFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5JDEsIHNsb3RzW2tleSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkkMiBpbiByZXMpKSB7XG4gICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICB2YXIgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiAoXG4gICAgICByZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiByZXNbMF0uaXNDb21tZW50KSAvLyAjOTY1OFxuICAgICkgPyB1bmRlZmluZWRcbiAgICAgIDogcmVzXG4gIH07XG4gIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gIGlmIChmbi5wcm94eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRcbn1cblxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXMsXG4gIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICBoYXNEeW5hbWljS2V5cyxcbiAgY29udGVudEhhc2hLZXlcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzIChiYXNlT2JqLCB2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlaWNhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rJDEodG9NZXJnZSwgZXhpc3RpbmcpIDogdG9NZXJnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gIDsoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIHZhciBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICBpZiAoXG4gICAgICBBcnJheS5pc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICkge1xuICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdWVzIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb25seSBhIHNpbmdsZSBub2RlLCBhbGxvdyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3Jcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgIHZhciBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgIHZhciB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgIHZhciB0aW1lclRpbWVvdXQgPSBudWxsXG5cbiAgICA7KG93bmVyKS4kb24oJ2hvb2s6ZGVzdHJveWVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlKG93bmVycywgb3duZXIpOyB9KTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAob3duZXJzW2ldKS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmcpO1xuICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlICgpIHtcbiAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxudmFyIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG52YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbi8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4vLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcbi8vIGltcGxlbWVudGF0aW9ucyAoIzk2MzIpXG5pZiAoaW5Ccm93c2VyICYmICFpc0lFKSB7XG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgaWYgKFxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wXG4gICkge1xuICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAvLyBzbWFsbGVyIHRoYW4gaXQsIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgIC8vIHdlbGwuXG4gICAgZ2V0Tm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH07XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlmICh3YXRjaGVyLmJlZm9yZSkge1xuICAgICAgd2F0Y2hlci5iZWZvcmUoKTtcbiAgICB9XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xuICAgIH1cbiAgfVxuICAvLyBvYnNlcnZlIGRhdGFcbiAgb2JzZXJ2ZShkYXRhLCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIHZhciBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiICsgKHR5cGVvZiBtZXRob2RzW2tleV0pICsgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzJDEsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuMTAnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWlzRGVmKGtleSkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICBmdW5jdGlvbiBjcmVhdGVFbG0gKFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtLFxuICAgIG5lc3RlZCxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4XG4gICkge1xuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChcbiAgICBvbGRWbm9kZSxcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleCxcbiAgICByZW1vdmVPbmx5XG4gICkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgdmFyIGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbnZhciBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICBjdXIgIT09IG9sZFByb3BzW2tleV1cbiAgICApIHtcbiAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcblxudmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICB0aGlzJDEuX19wYXRjaF9fKFxuICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICB0aGlzJDEua2VwdCxcbiAgICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICk7XG4gICAgICB0aGlzJDEuX3Zub2RlID0gdGhpcyQxLmtlcHQ7XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMkMSwgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcbiIsImltcG9ydCB0IGZyb21cImRlZXBtZXJnZVwiO2ltcG9ydHtzZXQgYXMgZSxnZXQgYXMgcn1mcm9tXCJzaHZsXCI7ZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obixvLHUpe2Z1bmN0aW9uIGkodCxlLHIpe3RyeXtyZXR1cm4ocj1lLmdldEl0ZW0odCkpJiZ2b2lkIDAhPT1yP0pTT04ucGFyc2Uocik6dm9pZCAwfWNhdGNoKHQpe319aWYobz0obj1ufHx7fSkuc3RvcmFnZXx8d2luZG93JiZ3aW5kb3cubG9jYWxTdG9yYWdlLHU9bi5rZXl8fFwidnVleFwiLCFmdW5jdGlvbih0KXt0cnl7cmV0dXJuIHQuc2V0SXRlbShcIkBAXCIsMSksdC5yZW1vdmVJdGVtKFwiQEBcIiksITB9Y2F0Y2godCl7fXJldHVybiExfShvKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0b3JhZ2UgaW5zdGFuY2UgZ2l2ZW5cIik7cmV0dXJuIGZ1bmN0aW9uKGMpe3ZhciBhPXIobixcImdldFN0YXRlXCIsaSkodSxvKTtcIm9iamVjdFwiPT10eXBlb2YgYSYmbnVsbCE9PWEmJmMucmVwbGFjZVN0YXRlKHQoYy5zdGF0ZSxhLHthcnJheU1lcmdlOm4uYXJyYXlNZXJnZXJ8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9LGNsb25lOiExfSkpLChuLnN1YnNjcmliZXJ8fGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdC5zdWJzY3JpYmUoZSl9fSkoYykoZnVuY3Rpb24odCxpKXsobi5maWx0ZXJ8fGZ1bmN0aW9uKCl7cmV0dXJuITB9KSh0KSYmKG4uc2V0U3RhdGV8fGZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gci5zZXRJdGVtKHQsSlNPTi5zdHJpbmdpZnkoZSkpfSkodSwobi5yZWR1Y2VyfHxmdW5jdGlvbih0LG4pe3JldHVybiAwPT09bi5sZW5ndGg/dDpuLnJlZHVjZShmdW5jdGlvbihuLG8pe3JldHVybiBlKG4sbyxyKHQsbykpfSx7fSl9KShpLG4ucGF0aHN8fFtdKSxvKX0pfX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12dWV4LXBlcnNpc3RlZHN0YXRlLmVzLmpzLm1hcFxuIiwiLyoqXG4gKiB2dWV4IHYzLjEuMVxuICogKGMpIDIwMTkgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBhcHBseU1peGluIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIFZ1ZS5taXhpbih7IGJlZm9yZUNyZWF0ZTogdnVleEluaXQgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3ZlcnJpZGUgaW5pdCBhbmQgaW5qZWN0IHZ1ZXggaW5pdCBwcm9jZWR1cmVcbiAgICAvLyBmb3IgMS54IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIHZhciBfaW5pdCA9IFZ1ZS5wcm90b3R5cGUuX2luaXQ7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgb3B0aW9ucy5pbml0ID0gb3B0aW9ucy5pbml0XG4gICAgICAgID8gW3Z1ZXhJbml0XS5jb25jYXQob3B0aW9ucy5pbml0KVxuICAgICAgICA6IHZ1ZXhJbml0O1xuICAgICAgX2luaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZ1ZXggaW5pdCBob29rLCBpbmplY3RlZCBpbnRvIGVhY2ggaW5zdGFuY2VzIGluaXQgaG9va3MgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gdnVleEluaXQgKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAvLyBzdG9yZSBpbmplY3Rpb25cbiAgICBpZiAob3B0aW9ucy5zdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSB0eXBlb2Ygb3B0aW9ucy5zdG9yZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuc3RvcmUoKVxuICAgICAgICA6IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdGFyZ2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgPyB3aW5kb3dcbiAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZ2xvYmFsXG4gICAgOiB7fTtcbnZhciBkZXZ0b29sSG9vayA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG5mdW5jdGlvbiBkZXZ0b29sUGx1Z2luIChzdG9yZSkge1xuICBpZiAoIWRldnRvb2xIb29rKSB7IHJldHVybiB9XG5cbiAgc3RvcmUuX2RldnRvb2xIb29rID0gZGV2dG9vbEhvb2s7XG5cbiAgZGV2dG9vbEhvb2suZW1pdCgndnVleDppbml0Jywgc3RvcmUpO1xuXG4gIGRldnRvb2xIb29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gIH0pO1xuXG4gIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgZGV2dG9vbEhvb2suZW1pdCgndnVleDptdXRhdGlvbicsIG11dGF0aW9uLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgaXRlbSB0aGF0IHBhc3MgdGhlIHRlc3RcbiAqIGJ5IHNlY29uZCBhcmd1bWVudCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuLyoqXG4gKiBmb3JFYWNoIGZvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFZhbHVlIChvYmosIGZuKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihvYmpba2V5XSwga2V5KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbXNnKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcigoXCJbdnVleF0gXCIgKyBtc2cpKSB9XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWwgKGZuLCBhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4oYXJnKVxuICB9XG59XG5cbi8vIEJhc2UgZGF0YSBzdHJ1Y3QgZm9yIHN0b3JlJ3MgbW9kdWxlLCBwYWNrYWdlIHdpdGggc29tZSBhdHRyaWJ1dGUgYW5kIG1ldGhvZFxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIC8vIFN0b3JlIHNvbWUgY2hpbGRyZW4gaXRlbVxuICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIFN0b3JlIHRoZSBvcmlnaW4gbW9kdWxlIG9iamVjdCB3aGljaCBwYXNzZWQgYnkgcHJvZ3JhbW1lclxuICB0aGlzLl9yYXdNb2R1bGUgPSByYXdNb2R1bGU7XG4gIHZhciByYXdTdGF0ZSA9IHJhd01vZHVsZS5zdGF0ZTtcblxuICAvLyBTdG9yZSB0aGUgb3JpZ2luIG1vZHVsZSdzIHN0YXRlXG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IG5hbWVzcGFjZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLm5hbWVzcGFjZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISF0aGlzLl9yYXdNb2R1bGUubmFtZXNwYWNlZFxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkIChrZXksIG1vZHVsZSkge1xuICB0aGlzLl9jaGlsZHJlbltrZXldID0gbW9kdWxlO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChrZXkpIHtcbiAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW2tleV07XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQgKGtleSkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRyZW5ba2V5XVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHJhd01vZHVsZSkge1xuICB0aGlzLl9yYXdNb2R1bGUubmFtZXNwYWNlZCA9IHJhd01vZHVsZS5uYW1lc3BhY2VkO1xuICBpZiAocmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucyA9IHJhd01vZHVsZS5hY3Rpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucyA9IHJhd01vZHVsZS5tdXRhdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5nZXR0ZXJzKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmdldHRlcnMgPSByYXdNb2R1bGUuZ2V0dGVycztcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiBmb3JFYWNoQ2hpbGQgKGZuKSB7XG4gIGZvckVhY2hWYWx1ZSh0aGlzLl9jaGlsZHJlbiwgZm4pO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoR2V0dGVyID0gZnVuY3Rpb24gZm9yRWFjaEdldHRlciAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEFjdGlvbiA9IGZ1bmN0aW9uIGZvckVhY2hBY3Rpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hNdXRhdGlvbiA9IGZ1bmN0aW9uIGZvckVhY2hNdXRhdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucywgZm4pO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTW9kdWxlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJlZ2lzdGVyKFtdLCByYXdSb290TW9kdWxlLCBmYWxzZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChtb2R1bGUsIGtleSkge1xuICAgIHJldHVybiBtb2R1bGUuZ2V0Q2hpbGQoa2V5KVxuICB9LCB0aGlzLnJvb3QpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROYW1lc3BhY2UgPSBmdW5jdGlvbiBnZXROYW1lc3BhY2UgKHBhdGgpIHtcbiAgdmFyIG1vZHVsZSA9IHRoaXMucm9vdDtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGtleSkge1xuICAgIG1vZHVsZSA9IG1vZHVsZS5nZXRDaGlsZChrZXkpO1xuICAgIHJldHVybiBuYW1lc3BhY2UgKyAobW9kdWxlLm5hbWVzcGFjZWQgPyBrZXkgKyAnLycgOiAnJylcbiAgfSwgJycpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAocmF3Um9vdE1vZHVsZSkge1xuICB1cGRhdGUoW10sIHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIHJhd01vZHVsZSk7XG4gIH1cblxuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnJvb3QgPSBuZXdNb2R1bGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gcmVnaXN0ZXIgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3Q2hpbGRNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFwYXJlbnQuZ2V0Q2hpbGQoa2V5KS5ydW50aW1lKSB7IHJldHVybiB9XG5cbiAgcGFyZW50LnJlbW92ZUNoaWxkKGtleSk7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGUgKHBhdGgsIHRhcmdldE1vZHVsZSwgbmV3TW9kdWxlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UmF3TW9kdWxlKHBhdGgsIG5ld01vZHVsZSk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiW3Z1ZXhdIHRyeWluZyB0byBhZGQgYSBuZXcgbW9kdWxlICdcIiArIGtleSArIFwiJyBvbiBob3QgcmVsb2FkaW5nLCBcIiArXG4gICAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShcbiAgICAgICAgcGF0aC5jb25jYXQoa2V5KSxcbiAgICAgICAgdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSksXG4gICAgICAgIG5ld01vZHVsZS5tb2R1bGVzW2tleV1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmdW5jdGlvbkFzc2VydCA9IHtcbiAgYXNzZXJ0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgZXhwZWN0ZWQ6ICdmdW5jdGlvbidcbn07XG5cbnZhciBvYmplY3RBc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUuaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyk7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24gb3Igb2JqZWN0IHdpdGggXCJoYW5kbGVyXCIgZnVuY3Rpb24nXG59O1xuXG52YXIgYXNzZXJ0VHlwZXMgPSB7XG4gIGdldHRlcnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBtdXRhdGlvbnM6IGZ1bmN0aW9uQXNzZXJ0LFxuICBhY3Rpb25zOiBvYmplY3RBc3NlcnRcbn07XG5cbmZ1bmN0aW9uIGFzc2VydFJhd01vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIE9iamVjdC5rZXlzKGFzc2VydFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXJhd01vZHVsZVtrZXldKSB7IHJldHVybiB9XG5cbiAgICB2YXIgYXNzZXJ0T3B0aW9ucyA9IGFzc2VydFR5cGVzW2tleV07XG5cbiAgICBmb3JFYWNoVmFsdWUocmF3TW9kdWxlW2tleV0sIGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBhc3NlcnRPcHRpb25zLmFzc2VydCh2YWx1ZSksXG4gICAgICAgIG1ha2VBc3NlcnRpb25NZXNzYWdlKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGFzc2VydE9wdGlvbnMuZXhwZWN0ZWQpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzc2VydGlvbk1lc3NhZ2UgKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUsIGV4cGVjdGVkKSB7XG4gIHZhciBidWYgPSBrZXkgKyBcIiBzaG91bGQgYmUgXCIgKyBleHBlY3RlZCArIFwiIGJ1dCBcXFwiXCIgKyBrZXkgKyBcIi5cIiArIHR5cGUgKyBcIlxcXCJcIjtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIGJ1ZiArPSBcIiBpbiBtb2R1bGUgXFxcIlwiICsgKHBhdGguam9pbignLicpKSArIFwiXFxcIlwiO1xuICB9XG4gIGJ1ZiArPSBcIiBpcyBcIiArIChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpICsgXCIuXCI7XG4gIHJldHVybiBidWZcbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAvLyBBdXRvIGluc3RhbGwgaWYgaXQgaXMgbm90IGRvbmUgeWV0IGFuZCBgd2luZG93YCBoYXMgYFZ1ZWAuXG4gIC8vIFRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIGF1dG8taW5zdGFsbGF0aW9uIGluIHNvbWUgY2FzZXMsXG4gIC8vIHRoaXMgY29kZSBzaG91bGQgYmUgcGxhY2VkIGhlcmUuIFNlZSAjNzMxXG4gIGlmICghVnVlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTdG9yZSwgXCJzdG9yZSBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3IuXCIpO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICAvLyBzdG9yZSBpbnRlcm5hbCBzdGF0ZVxuICB0aGlzLl9jb21taXR0aW5nID0gZmFsc2U7XG4gIHRoaXMuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX21vZHVsZXMgPSBuZXcgTW9kdWxlQ29sbGVjdGlvbihvcHRpb25zKTtcbiAgdGhpcy5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX3dhdGNoZXJWTSA9IG5ldyBWdWUoKTtcblxuICAvLyBiaW5kIGNvbW1pdCBhbmQgZGlzcGF0Y2ggdG8gc2VsZlxuICB2YXIgc3RvcmUgPSB0aGlzO1xuICB2YXIgcmVmID0gdGhpcztcbiAgdmFyIGRpc3BhdGNoID0gcmVmLmRpc3BhdGNoO1xuICB2YXIgY29tbWl0ID0gcmVmLmNvbW1pdDtcbiAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uIGJvdW5kRGlzcGF0Y2ggKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2guY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZClcbiAgfTtcbiAgdGhpcy5jb21taXQgPSBmdW5jdGlvbiBib3VuZENvbW1pdCAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21taXQuY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZCwgb3B0aW9ucylcbiAgfTtcblxuICAvLyBzdHJpY3QgbW9kZVxuICB0aGlzLnN0cmljdCA9IHN0cmljdDtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9tb2R1bGVzLnJvb3Quc3RhdGU7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xuXG4gIHZhciB1c2VEZXZ0b29scyA9IG9wdGlvbnMuZGV2dG9vbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGV2dG9vbHMgOiBWdWUuY29uZmlnLmRldnRvb2xzO1xuICBpZiAodXNlRGV2dG9vbHMpIHtcbiAgICBkZXZ0b29sUGx1Z2luKHRoaXMpO1xuICB9XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IHN0YXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnN0YXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZtLl9kYXRhLiQkc3RhdGVcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVzZSBzdG9yZS5yZXBsYWNlU3RhdGUoKSB0byBleHBsaWNpdCByZXBsYWNlIHN0b3JlIHN0YXRlLlwiKTtcbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uIGNvbW1pdCAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBjb21taXRcbiAgdmFyIHJlZiA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgcGF5bG9hZCA9IHJlZi5wYXlsb2FkO1xuICAgIHZhciBvcHRpb25zID0gcmVmLm9wdGlvbnM7XG5cbiAgdmFyIG11dGF0aW9uID0geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkIH07XG4gIHZhciBlbnRyeSA9IHRoaXMuX211dGF0aW9uc1t0eXBlXTtcbiAgaWYgKCFlbnRyeSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgb3B0aW9ucyAmJiBvcHRpb25zLnNpbGVudFxuICApIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlt2dWV4XSBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUgKyBcIi4gU2lsZW50IG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBcIiArXG4gICAgICAnVXNlIHRoZSBmaWx0ZXIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgdnVlLWRldnRvb2xzJ1xuICAgICk7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChfdHlwZSwgX3BheWxvYWQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgZGlzcGF0Y2hcbiAgdmFyIHJlZiA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG5cbiAgdmFyIGFjdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gYWN0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnNcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLmJlZm9yZTsgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5iZWZvcmUoYWN0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbdnVleF0gZXJyb3IgaW4gYmVmb3JlIGFjdGlvbiBzdWJzY3JpYmVyczogXCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpO1xuXG4gIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMkMS5fYWN0aW9uU3Vic2NyaWJlcnNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIuYWZ0ZXI7IH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi5hZnRlcihhY3Rpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlt2dWV4XSBlcnJvciBpbiBhZnRlciBhY3Rpb24gc3Vic2NyaWJlcnM6IFwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4pIHtcbiAgcmV0dXJuIGdlbmVyaWNTdWJzY3JpYmUoZm4sIHRoaXMuX3N1YnNjcmliZXJzKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZUFjdGlvbiA9IGZ1bmN0aW9uIHN1YnNjcmliZUFjdGlvbiAoZm4pIHtcbiAgdmFyIHN1YnMgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyB7IGJlZm9yZTogZm4gfSA6IGZuO1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShzdWJzLCB0aGlzLl9hY3Rpb25TdWJzY3JpYmVycylcbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3dhdGNoZXJWTS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXMkMS5zdGF0ZSwgdGhpcyQxLmdldHRlcnMpOyB9LCBjYiwgb3B0aW9ucylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiByZXBsYWNlU3RhdGUgKHN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLl92bS5fZGF0YS4kJHN0YXRlID0gc3RhdGU7XG4gIH0pO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gICAgYXNzZXJ0KHBhdGgubGVuZ3RoID4gMCwgJ2Nhbm5vdCByZWdpc3RlciB0aGUgcm9vdCBtb2R1bGUgYnkgdXNpbmcgcmVnaXN0ZXJNb2R1bGUuJyk7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCksIG9wdGlvbnMucHJlc2VydmVTdGF0ZSk7XG4gIC8vIHJlc2V0IHN0b3JlIHRvIHVwZGF0ZSBnZXR0ZXJzLi4uXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCB0aGlzLnN0YXRlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51bnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gdW5yZWdpc3Rlck1vZHVsZSAocGF0aCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbmZ1bmN0aW9uIGdlbmVyaWNTdWJzY3JpYmUgKGZuLCBzdWJzKSB7XG4gIGlmIChzdWJzLmluZGV4T2YoZm4pIDwgMCkge1xuICAgIHN1YnMucHVzaChmbik7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHN1YnMuaW5kZXhPZihmbik7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgc3Vicy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmUgKHN0b3JlLCBob3QpIHtcbiAgc3RvcmUuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgc3RhdGUgPSBzdG9yZS5zdGF0ZTtcbiAgLy8gaW5pdCBhbGwgbW9kdWxlc1xuICBpbnN0YWxsTW9kdWxlKHN0b3JlLCBzdGF0ZSwgW10sIHN0b3JlLl9tb2R1bGVzLnJvb3QsIHRydWUpO1xuICAvLyByZXNldCB2bVxuICByZXNldFN0b3JlVk0oc3RvcmUsIHN0YXRlLCBob3QpO1xufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlVk0gKHN0b3JlLCBzdGF0ZSwgaG90KSB7XG4gIHZhciBvbGRWbSA9IHN0b3JlLl92bTtcblxuICAvLyBiaW5kIHN0b3JlIHB1YmxpYyBnZXR0ZXJzXG4gIHN0b3JlLmdldHRlcnMgPSB7fTtcbiAgdmFyIHdyYXBwZWRHZXR0ZXJzID0gc3RvcmUuX3dyYXBwZWRHZXR0ZXJzO1xuICB2YXIgY29tcHV0ZWQgPSB7fTtcbiAgZm9yRWFjaFZhbHVlKHdyYXBwZWRHZXR0ZXJzLCBmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgIC8vIHVzZSBjb21wdXRlZCB0byBsZXZlcmFnZSBpdHMgbGF6eS1jYWNoaW5nIG1lY2hhbmlzbVxuICAgIC8vIGRpcmVjdCBpbmxpbmUgZnVuY3Rpb24gdXNlIHdpbGwgbGVhZCB0byBjbG9zdXJlIHByZXNlcnZpbmcgb2xkVm0uXG4gICAgLy8gdXNpbmcgcGFydGlhbCB0byByZXR1cm4gZnVuY3Rpb24gd2l0aCBvbmx5IGFyZ3VtZW50cyBwcmVzZXJ2ZWQgaW4gY2xvc3VyZSBlbnZpcm9tZW50LlxuICAgIGNvbXB1dGVkW2tleV0gPSBwYXJ0aWFsKGZuLCBzdG9yZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLmdldHRlcnMsIGtleSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5fdm1ba2V5XTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUgLy8gZm9yIGxvY2FsIGdldHRlcnNcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gIC8vIHN1cHByZXNzIHdhcm5pbmdzIGp1c3QgaW4gY2FzZSB0aGUgdXNlciBoYXMgYWRkZWRcbiAgLy8gc29tZSBmdW5reSBnbG9iYWwgbWl4aW5zXG4gIHZhciBzaWxlbnQgPSBWdWUuY29uZmlnLnNpbGVudDtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICBzdG9yZS5fdm0gPSBuZXcgVnVlKHtcbiAgICBkYXRhOiB7XG4gICAgICAkJHN0YXRlOiBzdGF0ZVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkXG4gIH0pO1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHNpbGVudDtcblxuICAvLyBlbmFibGUgc3RyaWN0IG1vZGUgZm9yIG5ldyB2bVxuICBpZiAoc3RvcmUuc3RyaWN0KSB7XG4gICAgZW5hYmxlU3RyaWN0TW9kZShzdG9yZSk7XG4gIH1cblxuICBpZiAob2xkVm0pIHtcbiAgICBpZiAoaG90KSB7XG4gICAgICAvLyBkaXNwYXRjaCBjaGFuZ2VzIGluIGFsbCBzdWJzY3JpYmVkIHdhdGNoZXJzXG4gICAgICAvLyB0byBmb3JjZSBnZXR0ZXIgcmUtZXZhbHVhdGlvbiBmb3IgaG90IHJlbG9hZGluZy5cbiAgICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2xkVm0uX2RhdGEuJCRzdGF0ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9sZFZtLiRkZXN0cm95KCk7IH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNb2R1bGUgKHN0b3JlLCByb290U3RhdGUsIHBhdGgsIG1vZHVsZSwgaG90KSB7XG4gIHZhciBpc1Jvb3QgPSAhcGF0aC5sZW5ndGg7XG4gIHZhciBuYW1lc3BhY2UgPSBzdG9yZS5fbW9kdWxlcy5nZXROYW1lc3BhY2UocGF0aCk7XG5cbiAgLy8gcmVnaXN0ZXIgaW4gbmFtZXNwYWNlIG1hcFxuICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHtcbiAgICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdID0gbW9kdWxlO1xuICB9XG5cbiAgLy8gc2V0IHN0YXRlXG4gIGlmICghaXNSb290ICYmICFob3QpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZShyb290U3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICB2YXIgbW9kdWxlTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBWdWUuc2V0KHBhcmVudFN0YXRlLCBtb2R1bGVOYW1lLCBtb2R1bGUuc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGxvY2FsID0gbW9kdWxlLmNvbnRleHQgPSBtYWtlTG9jYWxDb250ZXh0KHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpO1xuXG4gIG1vZHVsZS5mb3JFYWNoTXV0YXRpb24oZnVuY3Rpb24gKG11dGF0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIG11dGF0aW9uLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQWN0aW9uKGZ1bmN0aW9uIChhY3Rpb24sIGtleSkge1xuICAgIHZhciB0eXBlID0gYWN0aW9uLnJvb3QgPyBrZXkgOiBuYW1lc3BhY2UgKyBrZXk7XG4gICAgdmFyIGhhbmRsZXIgPSBhY3Rpb24uaGFuZGxlciB8fCBhY3Rpb247XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RvcmUuX2FjdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIGFjdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2godHlwZSwgcGF5bG9hZClcbiAgICB9LFxuXG4gICAgY29tbWl0OiBub05hbWVzcGFjZSA/IHN0b3JlLmNvbW1pdCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RvcmUuX211dGF0aW9uc1t0eXBlXSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbG9jYWwgbXV0YXRpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcmUuY29tbWl0KHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXR0ZXJzIGFuZCBzdGF0ZSBvYmplY3QgbXVzdCBiZSBnb3R0ZW4gbGF6aWx5XG4gIC8vIGJlY2F1c2UgdGhleSB3aWxsIGJlIGNoYW5nZWQgYnkgdm0gdXBkYXRlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxvY2FsLCB7XG4gICAgZ2V0dGVyczoge1xuICAgICAgZ2V0OiBub05hbWVzcGFjZVxuICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlTG9jYWxHZXR0ZXJzKHN0b3JlLCBuYW1lc3BhY2UpOyB9XG4gICAgfSxcbiAgICBzdGF0ZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXROZXN0ZWRTdGF0ZShzdG9yZS5zdGF0ZSwgcGF0aCk7IH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsb2NhbFxufVxuXG5mdW5jdGlvbiBtYWtlTG9jYWxHZXR0ZXJzIChzdG9yZSwgbmFtZXNwYWNlKSB7XG4gIHZhciBnZXR0ZXJzUHJveHkgPSB7fTtcblxuICB2YXIgc3BsaXRQb3MgPSBuYW1lc3BhY2UubGVuZ3RoO1xuICBPYmplY3Qua2V5cyhzdG9yZS5nZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgLy8gc2tpcCBpZiB0aGUgdGFyZ2V0IGdldHRlciBpcyBub3QgbWF0Y2ggdGhpcyBuYW1lc3BhY2VcbiAgICBpZiAodHlwZS5zbGljZSgwLCBzcGxpdFBvcykgIT09IG5hbWVzcGFjZSkgeyByZXR1cm4gfVxuXG4gICAgLy8gZXh0cmFjdCBsb2NhbCBnZXR0ZXIgdHlwZVxuICAgIHZhciBsb2NhbFR5cGUgPSB0eXBlLnNsaWNlKHNwbGl0UG9zKTtcblxuICAgIC8vIEFkZCBhIHBvcnQgdG8gdGhlIGdldHRlcnMgcHJveHkuXG4gICAgLy8gRGVmaW5lIGFzIGdldHRlciBwcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXZhbHVhdGUgdGhlIGdldHRlcnMgaW4gdGhpcyB0aW1lLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXR0ZXJzUHJveHksIGxvY2FsVHlwZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzW3R5cGVdOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZ2V0dGVyc1Byb3h5XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTXV0YXRpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fbXV0YXRpb25zW3R5cGVdIHx8IChzdG9yZS5fbXV0YXRpb25zW3R5cGVdID0gW10pO1xuICBlbnRyeS5wdXNoKGZ1bmN0aW9uIHdyYXBwZWRNdXRhdGlvbkhhbmRsZXIgKHBheWxvYWQpIHtcbiAgICBoYW5kbGVyLmNhbGwoc3RvcmUsIGxvY2FsLnN0YXRlLCBwYXlsb2FkKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQWN0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX2FjdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9hY3Rpb25zW3R5cGVdID0gW10pO1xuICBlbnRyeS5wdXNoKGZ1bmN0aW9uIHdyYXBwZWRBY3Rpb25IYW5kbGVyIChwYXlsb2FkLCBjYikge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmNhbGwoc3RvcmUsIHtcbiAgICAgIGRpc3BhdGNoOiBsb2NhbC5kaXNwYXRjaCxcbiAgICAgIGNvbW1pdDogbG9jYWwuY29tbWl0LFxuICAgICAgZ2V0dGVyczogbG9jYWwuZ2V0dGVycyxcbiAgICAgIHN0YXRlOiBsb2NhbC5zdGF0ZSxcbiAgICAgIHJvb3RHZXR0ZXJzOiBzdG9yZS5nZXR0ZXJzLFxuICAgICAgcm9vdFN0YXRlOiBzdG9yZS5zdGF0ZVxuICAgIH0sIHBheWxvYWQsIGNiKTtcbiAgICBpZiAoIWlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMgPSBQcm9taXNlLnJlc29sdmUocmVzKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlLl9kZXZ0b29sSG9vaykge1xuICAgICAgcmV0dXJuIHJlcy5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHN0b3JlLl9kZXZ0b29sSG9vay5lbWl0KCd2dWV4OmVycm9yJywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJHZXR0ZXIgKHN0b3JlLCB0eXBlLCByYXdHZXR0ZXIsIGxvY2FsKSB7XG4gIGlmIChzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gZHVwbGljYXRlIGdldHRlciBrZXk6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLiQkc3RhdGUgfSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQoc3RvcmUuX2NvbW1pdHRpbmcsIFwiZG8gbm90IG11dGF0ZSB2dWV4IHN0b3JlIHN0YXRlIG91dHNpZGUgbXV0YXRpb24gaGFuZGxlcnMuXCIpO1xuICAgIH1cbiAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROZXN0ZWRTdGF0ZSAoc3RhdGUsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoXG4gICAgPyBwYXRoLnJlZHVjZShmdW5jdGlvbiAoc3RhdGUsIGtleSkgeyByZXR1cm4gc3RhdGVba2V5XTsgfSwgc3RhdGUpXG4gICAgOiBzdGF0ZVxufVxuXG5mdW5jdGlvbiB1bmlmeU9iamVjdFN0eWxlICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gIGlmIChpc09iamVjdCh0eXBlKSAmJiB0eXBlLnR5cGUpIHtcbiAgICBvcHRpb25zID0gcGF5bG9hZDtcbiAgICBwYXlsb2FkID0gdHlwZTtcbiAgICB0eXBlID0gdHlwZS50eXBlO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnLCAoXCJleHBlY3RzIHN0cmluZyBhcyB0aGUgdHlwZSwgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiB0eXBlKSArIFwiLlwiKSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlICYmIF9WdWUgPT09IFZ1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW3Z1ZXhdIGFscmVhZHkgaW5zdGFsbGVkLiBWdWUudXNlKFZ1ZXgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIFZ1ZSA9IF9WdWU7XG4gIGFwcGx5TWl4aW4oVnVlKTtcbn1cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIGNvZGUgd2hpY2ggd3JpdHRlbiBpbiBWdWUuanMgZm9yIGdldHRpbmcgdGhlIHN0YXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2VdIC0gTW9kdWxlJ3MgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc3RhdGVzICMgT2JqZWN0J3MgaXRlbSBjYW4gYmUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHQgc3RhdGUgYW5kIGdldHRlcnMgZm9yIHBhcmFtLCB5b3UgY2FuIGRvIHNvbWV0aGluZyBmb3Igc3RhdGUgYW5kIGdldHRlcnMgaW4gaXQuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqL1xudmFyIG1hcFN0YXRlID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIHN0YXRlcykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChzdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRTdGF0ZSAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLiRzdG9yZS5zdGF0ZTtcbiAgICAgIHZhciBnZXR0ZXJzID0gdGhpcy4kc3RvcmUuZ2V0dGVycztcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwU3RhdGUnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gbW9kdWxlLmNvbnRleHQuc3RhdGU7XG4gICAgICAgIGdldHRlcnMgPSBtb2R1bGUuY29udGV4dC5nZXR0ZXJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuY2FsbCh0aGlzLCBzdGF0ZSwgZ2V0dGVycylcbiAgICAgICAgOiBzdGF0ZVt2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBjb21taXR0aW5nIHRoZSBtdXRhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2VdIC0gTW9kdWxlJ3MgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gbXV0YXRpb25zICMgT2JqZWN0J3MgaXRlbSBjYW4gYmUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHQgYGNvbW1pdGAgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtLCBpdCBjYW4gYWNjZXB0IGFudGhvciBwYXJhbXMuIFlvdSBjYW4gY29tbWl0IG11dGF0aW9uIGFuZCBkbyBhbnkgb3RoZXIgdGhpbmdzIGluIHRoaXMgZnVuY3Rpb24uIHNwZWNpYWxseSwgWW91IG5lZWQgdG8gcGFzcyBhbnRob3IgcGFyYW1zIGZyb20gdGhlIG1hcHBlZCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkTXV0YXRpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIC8vIEdldCB0aGUgY29tbWl0IG1ldGhvZCBmcm9tIHN0b3JlXG4gICAgICB2YXIgY29tbWl0ID0gdGhpcy4kc3RvcmUuY29tbWl0O1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBNdXRhdGlvbnMnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbW1pdCA9IG1vZHVsZS5jb250ZXh0LmNvbW1pdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmFwcGx5KHRoaXMsIFtjb21taXRdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgOiBjb21taXQuYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBnZXR0aW5nIHRoZSBnZXR0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZV0gLSBNb2R1bGUncyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBnZXR0ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBtYXBHZXR0ZXJzID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGdldHRlcnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICAvLyBUaGUgbmFtZXNwYWNlIGhhcyBiZWVuIG11dGF0ZWQgYnkgbm9ybWFsaXplTmFtZXNwYWNlXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogUmVkdWNlIHRoZSBjb2RlIHdoaWNoIHdyaXR0ZW4gaW4gVnVlLmpzIGZvciBkaXNwYXRjaCB0aGUgYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVzcGFjZV0gLSBNb2R1bGUncyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhY3Rpb25zICMgT2JqZWN0J3MgaXRlbSBjYW4gYmUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHQgYGRpc3BhdGNoYCBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW0sIGl0IGNhbiBhY2NlcHQgYW50aG9yIHBhcmFtcy4gWW91IGNhbiBkaXNwYXRjaCBhY3Rpb24gYW5kIGRvIGFueSBvdGhlciB0aGluZ3MgaW4gdGhpcyBmdW5jdGlvbi4gc3BlY2lhbGx5LCBZb3UgbmVlZCB0byBwYXNzIGFudGhvciBwYXJhbXMgZnJvbSB0aGUgbWFwcGVkIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRBY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIC8vIGdldCBkaXNwYXRjaCBmdW5jdGlvbiBmcm9tIHN0b3JlXG4gICAgICB2YXIgZGlzcGF0Y2ggPSB0aGlzLiRzdG9yZS5kaXNwYXRjaDtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwQWN0aW9ucycsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2ggPSBtb2R1bGUuY29udGV4dC5kaXNwYXRjaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmFwcGx5KHRoaXMsIFtkaXNwYXRjaF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICA6IGRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vKipcbiAqIFJlYmluZGluZyBuYW1lc3BhY2UgcGFyYW0gZm9yIG1hcFhYWCBmdW5jdGlvbiBpbiBzcGVjaWFsIHNjb3BlZCwgYW5kIHJldHVybiB0aGVtIGJ5IHNpbXBsZSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkgeyByZXR1cm4gKHtcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSlcbn0pOyB9O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgbWFwXG4gKiBub3JtYWxpemVNYXAoWzEsIDIsIDNdKSA9PiBbIHsga2V5OiAxLCB2YWw6IDEgfSwgeyBrZXk6IDIsIHZhbDogMiB9LCB7IGtleTogMywgdmFsOiAzIH0gXVxuICogbm9ybWFsaXplTWFwKHthOiAxLCBiOiAyLCBjOiAzfSkgPT4gWyB7IGtleTogJ2EnLCB2YWw6IDEgfSwgeyBrZXk6ICdiJywgdmFsOiAyIH0sIHsga2V5OiAnYycsIHZhbDogMyB9IF1cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBtYXBcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWFwIChtYXApIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWFwKVxuICAgID8gbWFwLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBrZXkgfSk7IH0pXG4gICAgOiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBtYXBba2V5XSB9KTsgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiBleHBlY3QgdHdvIHBhcmFtIGNvbnRhaW5zIG5hbWVzcGFjZSBhbmQgbWFwLiBpdCB3aWxsIG5vcm1hbGl6ZSB0aGUgbmFtZXNwYWNlIGFuZCB0aGVuIHRoZSBwYXJhbSdzIGZ1bmN0aW9uIHdpbGwgaGFuZGxlIHRoZSBuZXcgbmFtZXNwYWNlIGFuZCB0aGUgbWFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbi8qKlxuICogU2VhcmNoIGEgc3BlY2lhbCBtb2R1bGUgZnJvbSBzdG9yZSBieSBuYW1lc3BhY2UuIGlmIG1vZHVsZSBub3QgZXhpc3QsIHByaW50IGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWxwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWxlQnlOYW1lc3BhY2UgKHN0b3JlLCBoZWxwZXIsIG5hbWVzcGFjZSkge1xuICB2YXIgbW9kdWxlID0gc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1vZHVsZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIG1vZHVsZSBuYW1lc3BhY2Ugbm90IGZvdW5kIGluIFwiICsgaGVscGVyICsgXCIoKTogXCIgKyBuYW1lc3BhY2UpKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlXG59XG5cbnZhciBpbmRleF9lc20gPSB7XG4gIFN0b3JlOiBTdG9yZSxcbiAgaW5zdGFsbDogaW5zdGFsbCxcbiAgdmVyc2lvbjogJzMuMS4xJyxcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLFxuICBtYXBNdXRhdGlvbnM6IG1hcE11dGF0aW9ucyxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycyxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucyxcbiAgY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnM6IGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleF9lc207XG5leHBvcnQgeyBTdG9yZSwgaW5zdGFsbCwgbWFwU3RhdGUsIG1hcE11dGF0aW9ucywgbWFwR2V0dGVycywgbWFwQWN0aW9ucywgY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnMgfTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=